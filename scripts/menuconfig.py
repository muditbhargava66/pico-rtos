#!/usr/bin/env python3
"""
Pico-RTOS Menuconfig - Interactive Configuration Tool

This script provides a menuconfig-style interface for configuring Pico-RTOS
build options. It uses the kconfiglib library to parse Kconfig files and
provides an ncurses-based terminal interface.

Usage:
    python3 scripts/menuconfig.py [options]

Options:
    --config-file FILE    Load configuration from FILE (default: .config)
    --save-file FILE      Save configuration to FILE (default: .config)
    --cmake-file FILE     Generate CMake configuration file (default: cmake_config.cmake)
    --header-file FILE    Generate C header file (default: include/pico_rtos_config.h)
    --help               Show this help message

Dependencies:
    - kconfiglib: pip install kconfiglib
    - For GUI mode: pip install tkinter (usually included with Python)
"""

import sys
import os
import argparse
from pathlib import Path

try:
    import kconfiglib
except ImportError:
    print("Error: kconfiglib is required. Install with: pip install kconfiglib")
    sys.exit(1)

# Try to import menuconfig from kconfiglib
try:
    from kconfiglib import menuconfig
    MENUCONFIG_AVAILABLE = True
except ImportError:
    MENUCONFIG_AVAILABLE = False

def find_project_root():
    """Find the project root directory by looking for CMakeLists.txt"""
    current = Path.cwd()
    while current != current.parent:
        if (current / "CMakeLists.txt").exists():
            return current
        current = current.parent
    return Path.cwd()

def create_cmake_config(kconf, output_file):
    """Generate CMake configuration file from Kconfig"""
    
    cmake_content = """# Generated CMake configuration from Kconfig
# Do not edit this file manually - use 'make menuconfig' instead

"""
    
    # Build options
    cmake_content += "# Build Options\n"
    cmake_content += f"set(PICO_RTOS_BUILD_EXAMPLES {'ON' if get_config_value(kconf, 'BUILD_EXAMPLES') == 'y' else 'OFF'})\n"
    cmake_content += f"set(PICO_RTOS_BUILD_TESTS {'ON' if get_config_value(kconf, 'BUILD_TESTS') == 'y' else 'OFF'})\n"
    cmake_content += f"set(PICO_RTOS_ENABLE_DEBUG {'ON' if get_config_value(kconf, 'ENABLE_DEBUG') == 'y' else 'OFF'})\n"
    cmake_content += f"set(PICO_RTOS_ENABLE_INSTALL {'ON' if get_config_value(kconf, 'ENABLE_INSTALL') == 'y' else 'OFF'})\n"
    cmake_content += "\n"
    
    # System timing
    cmake_content += "# System Timing\n"
    if get_config_value(kconf, 'CUSTOM_TICK_RATE') == 'y':
        tick_rate = get_config_value(kconf, 'CUSTOM_TICK_RATE_VALUE', '1000')
    else:
        tick_rate = get_config_value(kconf, 'TICK_RATE_HZ', '1000')
    cmake_content += f"set(PICO_RTOS_TICK_RATE_HZ {tick_rate})\n"
    cmake_content += "\n"
    
    # System resources
    cmake_content += "# System Resources\n"
    cmake_content += f"set(PICO_RTOS_MAX_TASKS {get_config_value(kconf, 'MAX_TASKS', '16')})\n"
    cmake_content += f"set(PICO_RTOS_MAX_TIMERS {get_config_value(kconf, 'MAX_TIMERS', '8')})\n"
    cmake_content += f"set(PICO_RTOS_TASK_STACK_SIZE_DEFAULT {get_config_value(kconf, 'TASK_STACK_SIZE_DEFAULT', '1024')})\n"
    cmake_content += f"set(PICO_RTOS_IDLE_STACK_SIZE {get_config_value(kconf, 'IDLE_STACK_SIZE', '256')})\n"
    cmake_content += "\n"
    
    # Feature configuration
    cmake_content += "# Feature Configuration\n"
    cmake_content += f"set(PICO_RTOS_ENABLE_STACK_CHECKING {'ON' if get_config_value(kconf, 'ENABLE_STACK_CHECKING') == 'y' else 'OFF'})\n"
    cmake_content += f"set(PICO_RTOS_ENABLE_MEMORY_TRACKING {'ON' if get_config_value(kconf, 'ENABLE_MEMORY_TRACKING') == 'y' else 'OFF'})\n"
    cmake_content += f"set(PICO_RTOS_ENABLE_RUNTIME_STATS {'ON' if get_config_value(kconf, 'ENABLE_RUNTIME_STATS') == 'y' else 'OFF'})\n"
    cmake_content += "\n"
    
    # Error handling
    cmake_content += "# Error Handling\n"
    cmake_content += f"set(PICO_RTOS_ENABLE_ERROR_HISTORY {'ON' if get_config_value(kconf, 'ENABLE_ERROR_HISTORY') == 'y' else 'OFF'})\n"
    if get_config_value(kconf, 'ENABLE_ERROR_HISTORY') == 'y':
        cmake_content += f"set(PICO_RTOS_ERROR_HISTORY_SIZE {get_config_value(kconf, 'ERROR_HISTORY_SIZE', '10')})\n"
    cmake_content += "\n"
    
    # Debug logging
    cmake_content += "# Debug Logging\n"
    cmake_content += f"set(PICO_RTOS_ENABLE_LOGGING {'ON' if get_config_value(kconf, 'ENABLE_LOGGING') == 'y' else 'OFF'})\n"
    if get_config_value(kconf, 'ENABLE_LOGGING') == 'y':
        cmake_content += f"set(PICO_RTOS_LOG_LEVEL {get_config_value(kconf, 'LOG_LEVEL_VALUE', '0')})\n"
        cmake_content += f"set(PICO_RTOS_LOG_MESSAGE_MAX_LENGTH {get_config_value(kconf, 'LOG_MESSAGE_MAX_LENGTH', '128')})\n"
        cmake_content += f"set(PICO_RTOS_LOG_SUBSYSTEM_MASK {get_config_value(kconf, 'LOG_SUBSYSTEM_MASK', '0xFF')})\n"
    cmake_content += "\n"
    
    # Advanced configuration
    cmake_content += "# Advanced Configuration\n"
    cmake_content += f"set(PICO_RTOS_ENABLE_ASSERTIONS {'ON' if get_config_value(kconf, 'ENABLE_ASSERTIONS') == 'y' else 'OFF'})\n"
    cmake_content += f"set(PICO_RTOS_ENABLE_PROFILING {'ON' if get_config_value(kconf, 'ENABLE_PROFILING') == 'y' else 'OFF'})\n"
    cmake_content += "\n"
    
    # Hardware configuration
    cmake_content += "# Hardware Configuration\n"
    cmake_content += f"set(PICO_RTOS_ENABLE_HARDWARE_TIMERS {'ON' if get_config_value(kconf, 'ENABLE_HARDWARE_TIMERS') == 'y' else 'OFF'})\n"
    cmake_content += f"set(PICO_RTOS_TIMER_INTERRUPT_PRIORITY {get_config_value(kconf, 'TIMER_INTERRUPT_PRIORITY', '0')})\n"
    cmake_content += f"set(PICO_RTOS_ENABLE_CONTEXT_SWITCH_PROFILING {'ON' if get_config_value(kconf, 'ENABLE_CONTEXT_SWITCH_PROFILING') == 'y' else 'OFF'})\n"
    
    with open(output_file, 'w') as f:
        f.write(cmake_content)
    
    print(f"Generated CMake configuration: {output_file}")

def create_header_config(kconf, output_file):
    """Generate C header configuration file from Kconfig"""
    
    header_content = """/* Generated configuration header from Kconfig */
/* Do not edit this file manually - use 'make menuconfig' instead */

#ifndef PICO_RTOS_CONFIG_H
#define PICO_RTOS_CONFIG_H

"""
    
    # System timing
    header_content += "/* System Timing Configuration */\n"
    if get_config_value(kconf, 'CUSTOM_TICK_RATE') == 'y':
        tick_rate = get_config_value(kconf, 'CUSTOM_TICK_RATE_VALUE', '1000')
    else:
        tick_rate = get_config_value(kconf, 'TICK_RATE_HZ', '1000')
    header_content += f"#define PICO_RTOS_TICK_RATE_HZ {tick_rate}\n"
    header_content += f"#define PICO_RTOS_TICK_PERIOD_US ({1000000 // int(tick_rate)}UL)\n"
    header_content += "\n"
    
    # System resources
    header_content += "/* System Resource Limits */\n"
    header_content += f"#define PICO_RTOS_MAX_TASKS {get_config_value(kconf, 'MAX_TASKS', '16')}\n"
    header_content += f"#define PICO_RTOS_MAX_TIMERS {get_config_value(kconf, 'MAX_TIMERS', '8')}\n"
    header_content += f"#define PICO_RTOS_TASK_STACK_SIZE_DEFAULT {get_config_value(kconf, 'TASK_STACK_SIZE_DEFAULT', '1024')}\n"
    header_content += f"#define PICO_RTOS_IDLE_STACK_SIZE {get_config_value(kconf, 'IDLE_STACK_SIZE', '256')}\n"
    header_content += "\n"
    
    # Feature configuration
    header_content += "/* Feature Configuration */\n"
    header_content += f"#define PICO_RTOS_ENABLE_STACK_CHECKING {1 if get_config_value(kconf, 'ENABLE_STACK_CHECKING') == 'y' else 0}\n"
    header_content += f"#define PICO_RTOS_ENABLE_MEMORY_TRACKING {1 if get_config_value(kconf, 'ENABLE_MEMORY_TRACKING') == 'y' else 0}\n"
    header_content += f"#define PICO_RTOS_ENABLE_RUNTIME_STATS {1 if get_config_value(kconf, 'ENABLE_RUNTIME_STATS') == 'y' else 0}\n"
    header_content += "\n"
    
    # Error handling
    header_content += "/* Error Handling Configuration */\n"
    header_content += f"#define PICO_RTOS_ENABLE_ERROR_HISTORY {1 if get_config_value(kconf, 'ENABLE_ERROR_HISTORY') == 'y' else 0}\n"
    if get_config_value(kconf, 'ENABLE_ERROR_HISTORY') == 'y':
        header_content += f"#define PICO_RTOS_ERROR_HISTORY_SIZE {get_config_value(kconf, 'ERROR_HISTORY_SIZE', '10')}\n"
    header_content += "\n"
    
    # Debug logging
    header_content += "/* Debug Logging Configuration */\n"
    header_content += f"#define PICO_RTOS_ENABLE_LOGGING {1 if get_config_value(kconf, 'ENABLE_LOGGING') == 'y' else 0}\n"
    if get_config_value(kconf, 'ENABLE_LOGGING') == 'y':
        header_content += f"#define PICO_RTOS_DEFAULT_LOG_LEVEL {get_config_value(kconf, 'LOG_LEVEL_VALUE', '0')}\n"
        header_content += f"#define PICO_RTOS_LOG_MESSAGE_MAX_LENGTH {get_config_value(kconf, 'LOG_MESSAGE_MAX_LENGTH', '128')}\n"
        header_content += f"#define PICO_RTOS_DEFAULT_LOG_SUBSYSTEMS {get_config_value(kconf, 'LOG_SUBSYSTEM_MASK', '0xFF')}\n"
    header_content += "\n"
    
    # Advanced configuration
    header_content += "/* Advanced Configuration */\n"
    header_content += f"#define PICO_RTOS_ENABLE_ASSERTIONS {1 if get_config_value(kconf, 'ENABLE_ASSERTIONS') == 'y' else 0}\n"
    header_content += f"#define PICO_RTOS_ENABLE_PROFILING {1 if get_config_value(kconf, 'ENABLE_PROFILING') == 'y' else 0}\n"
    header_content += "\n"
    
    # Hardware configuration
    header_content += "/* Hardware Configuration */\n"
    header_content += f"#define PICO_RTOS_ENABLE_HARDWARE_TIMERS {1 if get_config_value(kconf, 'ENABLE_HARDWARE_TIMERS') == 'y' else 0}\n"
    header_content += f"#define PICO_RTOS_TIMER_INTERRUPT_PRIORITY {get_config_value(kconf, 'TIMER_INTERRUPT_PRIORITY', '0')}\n"
    header_content += f"#define PICO_RTOS_ENABLE_CONTEXT_SWITCH_PROFILING {1 if get_config_value(kconf, 'ENABLE_CONTEXT_SWITCH_PROFILING') == 'y' else 0}\n"
    header_content += "\n"
    
    # Validation macros
    header_content += "/* Configuration Validation */\n"
    header_content += "#if PICO_RTOS_TICK_RATE_HZ < 10 || PICO_RTOS_TICK_RATE_HZ > 10000\n"
    header_content += "#error \"PICO_RTOS_TICK_RATE_HZ must be between 10 and 10000 Hz\"\n"
    header_content += "#endif\n"
    header_content += "\n"
    header_content += "#if PICO_RTOS_MAX_TASKS < 1 || PICO_RTOS_MAX_TASKS > 64\n"
    header_content += "#error \"PICO_RTOS_MAX_TASKS must be between 1 and 64\"\n"
    header_content += "#endif\n"
    header_content += "\n"
    header_content += "#if PICO_RTOS_TASK_STACK_SIZE_DEFAULT < 256\n"
    header_content += "#error \"PICO_RTOS_TASK_STACK_SIZE_DEFAULT must be at least 256 bytes\"\n"
    header_content += "#endif\n"
    header_content += "\n"
    
    header_content += "#endif /* PICO_RTOS_CONFIG_H */\n"
    
    # Ensure directory exists
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    
    with open(output_file, 'w') as f:
        f.write(header_content)
    
    print(f"Generated C header configuration: {output_file}")

def load_defaults(kconf):
    """Load default configuration values"""
    # Set reasonable defaults
    defaults = {
        'BUILD_EXAMPLES': 'y',
        'BUILD_TESTS': 'y',
        'ENABLE_DEBUG': 'y',
        'ENABLE_INSTALL': 'n',
        'TICK_RATE_1000': 'y',
        'MAX_TASKS': '16',
        'MAX_TIMERS': '8',
        'TASK_STACK_SIZE_DEFAULT': '1024',
        'IDLE_STACK_SIZE': '256',
        'ENABLE_STACK_CHECKING': 'y',
        'ENABLE_MEMORY_TRACKING': 'y',
        'ENABLE_RUNTIME_STATS': 'y',
        'ENABLE_ERROR_HISTORY': 'y',
        'ERROR_HISTORY_SIZE': '10',
        'ENABLE_LOGGING': 'n',
        'LOG_LEVEL_INFO': 'y',
        'LOG_MESSAGE_MAX_LENGTH': '128',
        'LOG_SUBSYSTEM_CORE': 'y',
        'LOG_SUBSYSTEM_TASK': 'y',
        'LOG_SUBSYSTEM_MUTEX': 'y',
        'LOG_SUBSYSTEM_QUEUE': 'y',
        'LOG_SUBSYSTEM_TIMER': 'y',
        'LOG_SUBSYSTEM_MEMORY': 'y',
        'LOG_SUBSYSTEM_SEMAPHORE': 'y',
        'CUSTOM_TICK_RATE': 'n',
        'CUSTOM_TICK_RATE_VALUE': '1000',
        'ENABLE_ASSERTIONS': 'y',
        'ENABLE_PROFILING': 'n',
        'ENABLE_HARDWARE_TIMERS': 'y',
        'TIMER_INTERRUPT_PRIORITY': '0',
        'ENABLE_CONTEXT_SWITCH_PROFILING': 'n'
    }
    
    for name, value in defaults.items():
        sym = kconf.syms.get(name)
        if sym is not None:
            sym.set_value(value)

def get_config_value(kconf, name, default=''):
    """Helper function to safely get configuration values"""
    sym = kconf.syms.get(name)
    if sym is not None:
        return sym.str_value
    return default

def print_text_config(kconf):
    """Print current configuration in text format"""
    print("\n=== Pico-RTOS Configuration ===\n")
    
    print("Build Options:")
    print(f"  Build Examples: {'Yes' if get_config_value(kconf, 'BUILD_EXAMPLES') == 'y' else 'No'}")
    print(f"  Build Tests: {'Yes' if get_config_value(kconf, 'BUILD_TESTS') == 'y' else 'No'}")
    print(f"  Enable Debug: {'Yes' if get_config_value(kconf, 'ENABLE_DEBUG') == 'y' else 'No'}")
    print(f"  Enable Install: {'Yes' if get_config_value(kconf, 'ENABLE_INSTALL') == 'y' else 'No'}")
    print()
    
    print("System Timing:")
    if get_config_value(kconf, 'CUSTOM_TICK_RATE') == 'y':
        tick_rate = get_config_value(kconf, 'CUSTOM_TICK_RATE_VALUE', '1000')
        print(f"  Tick Rate: {tick_rate} Hz (custom)")
    else:
        tick_rate = get_config_value(kconf, 'TICK_RATE_HZ', '1000')
        print(f"  Tick Rate: {tick_rate} Hz")
    print(f"  Tick Period: {1000000 // int(tick_rate)} µs")
    print()
    
    print("System Resources:")
    print(f"  Max Tasks: {get_config_value(kconf, 'MAX_TASKS', '16')}")
    print(f"  Max Timers: {get_config_value(kconf, 'MAX_TIMERS', '8')}")
    print(f"  Default Task Stack: {get_config_value(kconf, 'TASK_STACK_SIZE_DEFAULT', '1024')} bytes")
    print(f"  Idle Task Stack: {get_config_value(kconf, 'IDLE_STACK_SIZE', '256')} bytes")
    print()
    
    print("Features:")
    print(f"  Stack Checking: {'Enabled' if get_config_value(kconf, 'ENABLE_STACK_CHECKING') == 'y' else 'Disabled'}")
    print(f"  Memory Tracking: {'Enabled' if get_config_value(kconf, 'ENABLE_MEMORY_TRACKING') == 'y' else 'Disabled'}")
    print(f"  Runtime Stats: {'Enabled' if get_config_value(kconf, 'ENABLE_RUNTIME_STATS') == 'y' else 'Disabled'}")
    print()
    
    print("Error Handling:")
    print(f"  Error History: {'Enabled' if get_config_value(kconf, 'ENABLE_ERROR_HISTORY') == 'y' else 'Disabled'}")
    if get_config_value(kconf, 'ENABLE_ERROR_HISTORY') == 'y':
        print(f"  History Size: {get_config_value(kconf, 'ERROR_HISTORY_SIZE', '10')} entries")
    print()
    
    print("Debug Logging:")
    print(f"  Logging: {'Enabled' if get_config_value(kconf, 'ENABLE_LOGGING') == 'y' else 'Disabled'}")
    if get_config_value(kconf, 'ENABLE_LOGGING') == 'y':
        log_levels = ['None', 'Error', 'Warning', 'Info', 'Debug']
        level_idx = int(get_config_value(kconf, 'LOG_LEVEL_VALUE', '0'))
        print(f"  Log Level: {log_levels[level_idx]}")
        print(f"  Max Message Length: {get_config_value(kconf, 'LOG_MESSAGE_MAX_LENGTH', '128')} chars")
        print(f"  Subsystem Mask: {get_config_value(kconf, 'LOG_SUBSYSTEM_MASK', '0xFF')}")
    print()

def main():
    parser = argparse.ArgumentParser(description='Pico-RTOS Configuration Tool')
    parser.add_argument('--config-file', default='config/.config',
                       help='Configuration file to load/save (default: config/.config)')
    parser.add_argument('--cmake-file', default='config/cmake_config.cmake',
                       help='CMake configuration file to generate (default: config/cmake_config.cmake)')
    parser.add_argument('--header-file', default='include/pico_rtos_config.h',
                       help='C header file to generate (default: include/pico_rtos_config.h)')
    parser.add_argument('--show-config', action='store_true',
                       help='Show current configuration and exit')
    parser.add_argument('--load-defaults', action='store_true',
                       help='Load default configuration')
    parser.add_argument('--gui', action='store_true',
                       help='Use GUI interface (requires tkinter)')
    
    args = parser.parse_args()
    
    # Find project root and Kconfig file
    project_root = find_project_root()
    kconfig_file = project_root / "Kconfig"
    
    if not kconfig_file.exists():
        print(f"Error: Kconfig file not found at {kconfig_file}")
        sys.exit(1)
    
    # Change to project root directory
    os.chdir(project_root)
    
    # Load Kconfig
    try:
        kconf = kconfiglib.Kconfig(str(kconfig_file))
    except Exception as e:
        print(f"Error loading Kconfig: {e}")
        sys.exit(1)
    
    # Load existing configuration or defaults
    config_file = Path(args.config_file)
    if config_file.exists() and not args.load_defaults:
        try:
            kconf.load_config(str(config_file))
            print(f"Loaded configuration from {config_file}")
        except Exception as e:
            print(f"Warning: Could not load config file {config_file}: {e}")
            print("Using defaults...")
            load_defaults(kconf)
    else:
        load_defaults(kconf)
        if args.load_defaults:
            print("Loaded default configuration")
    
    # Show configuration and exit if requested (but save first if loading defaults)
    if args.show_config:
        if args.load_defaults:
            # Save configuration and generate files when loading defaults
            try:
                kconf.write_config(args.config_file)
                create_cmake_config(kconf, args.cmake_file)
                create_header_config(kconf, args.header_file)
            except Exception as e:
                print(f"Warning: Could not save configuration: {e}")
        print_text_config(kconf)
        return
    
    # Run menuconfig interface
    if args.gui:
        try:
            from kconfiglib import guiconfig
            guiconfig.main(kconf)
        except ImportError:
            print("Error: GUI interface requires tkinter. Install with: pip install tkinter")
            print("Falling back to text interface...")
            if MENUCONFIG_AVAILABLE:
                menuconfig.main(kconf)
            else:
                print("Error: Neither GUI nor text menuconfig is available")
                sys.exit(1)
    else:
        if MENUCONFIG_AVAILABLE:
            menuconfig.main(kconf)
        else:
            print("Error: menuconfig interface not available")
            print("Install with: pip install kconfiglib")
            print("Or use --show-config to view current configuration")
            sys.exit(1)
    
    # Save configuration
    try:
        kconf.write_config(args.config_file)
        print(f"Configuration saved to {args.config_file}")
    except Exception as e:
        print(f"Error saving configuration: {e}")
        sys.exit(1)
    
    # Generate output files
    try:
        create_cmake_config(kconf, args.cmake_file)
        create_header_config(kconf, args.header_file)
    except Exception as e:
        print(f"Error generating configuration files: {e}")
        sys.exit(1)
    
    print("\nConfiguration complete!")
    print(f"Use 'cmake -C {args.cmake_file} .' to configure your build")

if __name__ == '__main__':
    main()